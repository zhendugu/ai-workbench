<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Instances</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: white;
            color: black;
        }
        .search-container {
            margin: 20px 0;
        }
        .search-container input {
            padding: 5px;
            border: 1px solid #000;
            font-family: monospace;
            width: 300px;
        }
        .pattern-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .pattern-item {
            margin: 5px 0;
            padding: 5px;
            border: 1px solid #ccc;
        }
        .pattern-item button {
            background: white;
            border: 1px solid #000;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
        }
        .pagination {
            margin: 20px 0;
        }
        .pagination button {
            background: white;
            border: 1px solid #000;
            padding: 5px 10px;
            cursor: pointer;
            font-family: monospace;
            margin: 0 5px;
        }
        .nav-link {
            margin: 10px 0;
            padding: 5px;
        }
        .nav-link a {
            color: #000;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Pattern Instances</h1>
    <div class="nav-link"><a href="capabilities.html">Capabilities</a> | <a href="audit_view.html">Audit View</a></div>
    
    <!-- Allowlist Item 2: Literal Search (No Ranking) -->
    <div class="search-container">
        <input type="text" id="search-input" placeholder="Search patterns">
    </div>
    
    <ul id="pattern-list" class="pattern-list"></ul>
    
    <!-- Allowlist Item 3: Pagination -->
    <div class="pagination" id="pagination"></div>

    <script>
        // Backend API base URL (configurable, but no automatic detection)
        const API_BASE_URL = 'http://localhost:8000';
        const API_TIMEOUT = 10000; // 10 seconds, no automatic adjustment

        // Allowlist Item 3: Pagination - Fixed page size
        const PAGE_SIZE = 2;
        let currentPage = 1;
        let patterns = []; // Loaded from backend

        // Load patterns from backend API
        async function loadPatterns() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT);
                
                const response = await fetch(`${API_BASE_URL}/api/patterns`, {
                    method: 'GET',
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    displayError(`Backend returned error: HTTP ${response.status} - ${errorText}`);
                    return;
                }
                
                const data = await response.json();
                
                if (data.error) {
                    displayError(`Backend returned error: ${data.error}`);
                    return;
                }
                
                if (data.patterns && Array.isArray(data.patterns)) {
                    patterns = data.patterns; // Store in registration order, no sorting
                    displayPatterns();
                } else if (data.patterns && data.patterns.length === 0) {
                    patterns = [];
                    displayPatterns(); // Display empty list as-is
                } else {
                    displayError(`Backend returned error: Invalid response format`);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    displayError(`Backend returned error: Request timeout after ${API_TIMEOUT / 1000} seconds`);
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    displayError(`Backend returned error: Connection failed - ${error.message}`);
                } else {
                    displayError(`Backend returned error: ${error.message}`);
                }
            }
        }

        // Display error (factual only, no interpretation)
        function displayError(errorMessage) {
            const list = document.getElementById('pattern-list');
            list.innerHTML = `<li style="color: red; padding: 10px; border: 1px solid red;">${errorMessage}</li>`;
        }

        // Allowlist Item 2: Literal Search (No Ranking) - Filter patterns
        function filterPatterns(query) {
            if (!query) {
                return patterns;
            }
            const lowerQuery = query.toLowerCase();
            return patterns.filter(pat => 
                pat.name.toLowerCase().includes(lowerQuery) || 
                pat.id.toLowerCase().includes(lowerQuery) ||
                (pat.description && pat.description.toLowerCase().includes(lowerQuery))
            );
        }

        // Display patterns in registration order (no sorting, no highlighting)
        function displayPatterns() {
            const searchInput = document.getElementById('search-input');
            const query = searchInput.value;
            const filtered = filterPatterns(query);
            
            const list = document.getElementById('pattern-list');
            list.innerHTML = '';
            
            // Pagination: Calculate start and end indices
            const startIndex = (currentPage - 1) * PAGE_SIZE;
            const endIndex = startIndex + PAGE_SIZE;
            const paginated = filtered.slice(startIndex, endIndex);
            
            paginated.forEach(pattern => {
                const item = document.createElement('li');
                item.className = 'pattern-item';
                const button = document.createElement('button');
                button.textContent = pattern.name;
                button.onclick = () => {
                    // Pattern detail view (if needed)
                    alert(`Pattern: ${pattern.name}\nID: ${pattern.id}\nDescription: ${pattern.description}`);
                };
                item.appendChild(button);
                list.appendChild(item);
            });
            
            // Display pagination controls
            displayPagination(filtered.length);
        }

        // Allowlist Item 3: Pagination - Display pagination controls
        function displayPagination(totalItems) {
            const paginationDiv = document.getElementById('pagination');
            paginationDiv.innerHTML = '';
            
            const totalPages = Math.ceil(totalItems / PAGE_SIZE);
            
            if (totalPages > 1) {
                if (currentPage > 1) {
                    const prevButton = document.createElement('button');
                    prevButton.textContent = 'Previous';
                    prevButton.onclick = () => {
                        currentPage--;
                        displayPatterns();
                    };
                    paginationDiv.appendChild(prevButton);
                }
                
                const pageInfo = document.createElement('span');
                pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                paginationDiv.appendChild(pageInfo);
                
                if (currentPage < totalPages) {
                    const nextButton = document.createElement('button');
                    nextButton.textContent = 'Next';
                    nextButton.onclick = () => {
                        currentPage++;
                        displayPatterns();
                    };
                    paginationDiv.appendChild(nextButton);
                }
            }
        }

        // Allowlist Item 2: Literal Search - Handle search input
        document.getElementById('search-input').addEventListener('input', (e) => {
            currentPage = 1; // Reset to first page on search
            displayPatterns();
        });

        // Initialize on page load - Load from backend
        loadPatterns();
    </script>
</body>
</html>

